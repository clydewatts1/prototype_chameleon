# Project Constitution: Chameleon Engine

**Status:** ACTIVE
**Enforcement:** MANDATORY
**Agent Access:** READ_ONLY

This document defines the non-negotiable principles, architectural constraints, and security standards for the Chameleon MCP Server. All AI agents and developers must adhere to these rules without exception.

---

## 1. Architectural Integrity (The "Dual-Engine" Law)

### 1.1 Separation of Concerns
The system operates on a **Strict Dual-Engine Architecture**. Code must never mix system metadata with business data in the same connection context.
* **Metadata Engine (`_meta_engine`):**
    * **Purpose:** Stores internal system state (`ToolRegistry`, `CodeVault`, `ExecutionLog`).
    * **Access:** Read/Write allowed by System Tools.
    * **Constraint:** NEVER stores business data or customer records.
* **Data Engine (`_data_engine`):**
    * **Purpose:** Connects to external business data sources (Sales, Inventory, etc.).
    * **Access:** **READ-ONLY** by default for Auto-Generated Tools.
    * **Constraint:** NEVER contains Chameleon system tables.

### 1.2 State Persistence
* **Code is Data:** All executable tool logic must be stored in the `CodeVault` table, referenced by SHA-256 hash.
* **No "Magic" Files:** Runtime logic should rely on the database state, not local file system hacks (except for initial bootstrapping/seeding).

---

## 2. Security & Safety (The "Do No Harm" Law)

### 2.1 The "Read-Only" Mandate
Any SQL tool generated by the AI (Auto-Tools) must be strictly **READ-ONLY**.
* **Allowed:** `SELECT`, `WITH`, `JOIN`, `GROUP BY`.
* **Forbidden:** `INSERT`, `UPDATE`, `DELETE`, `DROP`, `ALTER`, `GRANT`, `TRUNCATE`.
* **Validation:** All generated SQL must pass AST validation (via `sqlglot` or internal regex checks) before execution.

### 2.2 Execution Sandboxing
* **Input Validation:** All tool arguments must be typed and validated against the `input_schema`.
* **AST Policy:** Python tools must not import dangerous modules (`os`, `sys`, `subprocess`) unless explicitly whitelisted in `SecurityPolicy`.

### 2.3 Transparency
* **Auto-Flagging:** Any tool created by an LLM must have `is_auto_created=True` in the `ToolRegistry`.
* **Visual Indicators:** The UI and CLI must visually distinguish between "System Tools" (Human-verified) and "Auto Tools" (AI-generated).

---

## 3. Technology Stack (The "Standardization" Law)

To maintain stability and prevent dependency drift, the following technologies are mandated:

| Component | Standard | Constraint |
| :--- | :--- | :--- |
| **Language** | Python 3.10+ | Type hints are mandatory. |
| **ORM** | SQLModel | Do not use raw `sqlite3` or pure `SQLAlchemy` unless necessary for complex migrations. |
| **Testing** | Pytest | All new system tools must have a corresponding `tests/test_*.py`. |
| **Config** | YAML | Configuration must be loadable from `config.yaml`. |
| **Server** | MCP (Model Context Protocol) | Adhere strictly to MCP types (`CallToolRequest`, `TextContent`). |

---

## 4. Development Workflow

### 4.1 The "Verify" Step
No tool is considered "Done" until it has passed the `verify_tool` check.
1.  **Draft:** AI generates code.
2.  **Verify:** System runs syntax check + dry-run.
3.  **Commit:** Tool is saved to `ToolRegistry` only after verification.

### 4.2 Error Handling
* **Self-Correction:** If a tool fails, the error **must** be captured in `ExecutionLog`.
* **Feedback Loop:** The agent should use `get_last_error` to read the traceback and attempt *one* patch before asking for human help.

---

## 5. Documentation

* **Code Comments:** All Python functions must have docstrings in Google format.
* **Schema Descriptions:** Every field in a Tool's `input_schema` must have a meaningful `description`.